## 进程(都以单核CPU为基础)
打开一个计算器。弹出一个计算器窗口，这就是启动了一个进程。一个进程可以是一个窗口，也可以是多个窗口。再打开一个计算器，虽然两个功能是一样的，但是他们属于两个不同的进程。              
一个进程包括了输入、输出、程序和状态。比如我在计算器上输入1+1然后回车，这时候运行的是程序，程序执行完毕输出一个值。**程序不等于进程**       
CPU的处理速度是非常快的，是内存执行的100倍，而内存的执行速度又是硬盘执行速度的100000倍。但是一个CPU同一时间只能执行一个进程。       
之前我打开了一个计算器，我在考虑计算多少的时候，这个进程一直在占用CPU，导致其他的进程都不能执行了。这肯定是不愿看到的。所以有了一个`中断`操作。         
中断操作执行，会记录许多关于当前进程的信息，然后执行下一个进程。等到我终于想到该计算什么的时候，再把这些信息提取出来，恢复到上次运行到的地方。因为CPU处理的速度实在太快，人根本反应不过来，所以给了我们一个视觉上的假象。这些进程仿佛就是同时在进行（伪并行）。这种CPU进程来回切换被称为**多道程序设计**        
![顺序进程](../images/system-now/%E8%BF%9B%E7%A8%8B%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png)  

操作系统启动之后，会启动许多进程，跟前台人机互动的进程，也有默默无闻在后台运行的进程（守护进程）   

在linux系统查询一个文章里有没有自己想要的内容。
```s
cat txt1 | grep user
```
这命令同时启动了两个进程，一个cat，一个grep。他们没有先后顺序，几乎同时启动。只是grep需要输入，所以当cat还没有执行完毕的时候，grep只能阻塞在那里，等到cat执行完毕，将内容输入到grep当中，grep进入就绪状态，然后运行。
![状态](../images/system-now/three%20status.png)

## 线程
线程是CPU调度的最小单位。(php是单线程)          
在编写文档的时候，为了防止突然停电导致我编写的文档丢失，我需要经常保存。我觉得很麻烦，于是我设定了一个自动保存的时间，让他自己运行。但是保存这种事IO操作。CPU跟硬盘执行速度完全不是一个数量级。所以有的时候还在键盘里打字呢，突然就卡主了，以为电脑死机了。因为保存文件在运行，当前的输入处于阻塞状态。     
这种体验很差，于是要不再开一个进程来专门运行保存？可是进程与进程之前是隔离的，内存地址，信息都不相同。      
于是线程这个概念出现了，一个文档操作的进程内，弄三个线程，一个处理键盘输入，一个输出到显示屏，一个进行硬盘的读写。线程共享内存地址，以及子进程，定时器等相关信息。      
每个线程都有一个线程的堆栈，这里面存储了局部变量和返回地址，毕竟他们的工作是不相同的。线程跟进程一样，也是运行，就绪，阻塞三种状态。


