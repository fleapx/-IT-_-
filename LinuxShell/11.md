## 构建脚本
shell脚本的基本格式第一行是指用什么shell，第二行是注释。剩下的是脚本处理内容。
```
#!/bin/bash
# This script displays the date and who's logged on 
date 
who
```
这样一个简单的shell脚本就构建完成了。可以根据需要，使用分号将两个命令放在一行上，但在shell脚本 中，你可以在独立的行中书写命令。shell会按根据命令在文件中出现的顺序进行处理。 
尝试使用这个脚本，但是会报错
```
-bash: test1: command not found
```
shell执行的时候，是根据PATH当中的路径逐一循环查找各目录下有没有这个可执行文件。我们创建了这个脚本，但是脚本所在的目录并没有在PATH路径当中，所以无法执行。这种时候咋办呢？
- 将shell脚本文件所处的目录添加到PATH环境变量中； 
- 在提示符中用绝对或相对文件路径来引用shell脚本文件。
那么继续
```
[root@vultr /]# ./test1
-bash: ./test1: Permission denied
```
又报错了……这次是为啥，查看一下脚本的权限。
```
-rw-rw-r--    1 user     user           73 Sep 24 19:56 test1 
```
原来是没有执行的权限，那么久给他执行的权限`chmod u+x test1`再执行这个脚本
```
Wed Dec 26 17:34:50 CST 2018
root     pts/1        2018-12-26 11:03 (115.206.55.15)
```
终于执行成功了，也是不容易啊。

用echo输出一串字符串的时候是不需要引号的。但是假如这个字符串当中有引号，那么我们要用合适的引号将这个字符串包裹起来，才能正确的输出内容。
```
$ echo 'Rich says "scripting is easy".'
Rich says "scripting is easy". 
```

稍微修改一下脚本
```
#!/bin/bash 
# This script displays the date and who's logged on 
echo  The time and date are: 
date 
echo "Let's see who's logged into the system:" 
who

The time and date are:
Wed Dec 26 17:47:57 CST 2018
Let's see who's logged into the system:
root     pts/1        2018-12-26 11:03 (115.206.55.15)
```
想要输出在同一行，可以给echo命令加-n参数。

### 使用变量
系统定义了很多全局变量，我们可以把这些变量用到脚本当中去。
```
#!/bin/bash 
# display user information from the system. 
echo "User info for userid: $USER" 
echo UID: $UID 
echo HOME: $HOME

User info for userid: root
UID: 0
HOME: /root
```
echo命令中的环境变量会在脚本运行时替换成当前值。假如我们在脚本中输出美元符号，可以使用转义符（\）。
>你可能还见过通过${variable}形式引用的变量。变量名两侧额外的花括号通常用来帮 助识别美元符后的变量名。

我们也可以在脚本当中自定义一些变量使用
```
#!/bin/bash
# testing variables 
days=10 
guest="Katie" 
echo "$guest checked in $days days ago" 
days=5 
guest="Jessica" 
echo "$guest checked in $days days ago"

Katie checked in 10 days ago
Jessica checked in 5 days ago
```
**重要的是要记住，引用一个变量值时需要使 用美元符，而引用变量来对其进行赋值时则不要使用美元符。**
```
value1=10 
value2=$value1 
echo The resulting value is $value2
```


有两种方式可以将shell的命令赋值给变量。一种是反引号（\`），另一种是`$()`。
```
[root@vultr /]# echo $test
Wed Dec 26 18:00:44 CST 2018
[root@vultr /]# test1=$(date)
[root@vultr /]# echo $test1
Wed Dec 26 18:00:59 CST 2018
```
命令替换会创建一个子shell来运行对应的命令。子shell（subshell）是由运行该脚本的shell 所创建出来的一个独立的子shell（child shell）。正因如此，由该子shell所执行命令是无法 使用脚本中所创建的变量的。      
在命令行提示符下使用路径./运行命令的话，也会创建出子shell；要是运行命令的时候 不加入路径，就不会创建子shell。如果你使用的是内建的shell命令，并不会涉及子shell。     
在命令行提示符下运行脚本时一定要留心!


